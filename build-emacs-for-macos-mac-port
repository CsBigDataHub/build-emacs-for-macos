#!/usr/bin/env ruby
# frozen_string_literal: true

# Lightweight wrapper reusing build-emacs-for-macos implementation
# to build "Mac port" (jdtsmith/emacs-mac) without applying
# NS-port specific patches. This file delegates nearly all behavior to
# original build-emacs-for-macos script by subclassing Build and
# overriding a few methods.

load File.join(__dir__, "build-emacs-for-macos")

class MacPortBuild < Build
  def initialize(root_dir, ref = nil, options = {})
    options = (options || {}).dup
    if options[:dist_include].nil?
      options[:dist_include] = ["configure_output.txt", "COPYING"]
    else
      defaults = ["configure_output.txt", "COPYING"]
      options[:dist_include] = (options[:dist_include] + defaults).uniq
    end

    # Disable rsvg by default for mac-port builds
    options[:rsvg] = false if options[:rsvg].nil?

    super(root_dir, ref, options)
  end

  private

  def github_src_repo
    @github_src_repo ||= options[:github_src_repo] || "jdtsmith/emacs-mac"
  end

  def build_name
    return @build_name if @build_name
    return @build_name = options[:build_name] if options[:build_name]

    metadata =
      [
        meta[:date]&.strftime("%Y-%m-%d"),
        meta[:sha][0..6],
        meta[:ref],
        "mac-port",
        "macOS-#{OS.sdk_version}",
        OS.arch,
      ].compact.map { |v| v.gsub(/[^\w_-]+/, "-") }

    @build_name = "Emacs.#{metadata.join(".")}"
  end

  def apply_macos_startup_patch(_target)
    info "Skipping NS-port macOS startup patch for Mac-port"
  end

  def build_patches
    p = []
    options[:patches].each do |patch_str|
      patch = {}
      if valid_url?(patch_str)
        patch[:url] = patch_str
      elsif File.exist?(patch_str)
        patch[:file] = patch_str
      else
        fatal "Patch file or URL not found: #{patch_str}"
      end
      p << patch
    end
    p.uniq
  end

  # Override compile_source to handle Mac Port's installation quirks
  def compile_source(source)
    # Accept either mac-port or NS-port style prebuilt app directories
    ns_target = File.join(source, "nextstep")
    mac_target = File.join(source, "mac")
    ns_app = File.join(ns_target, "Emacs.app")
    mac_app = File.join(mac_target, "Emacs.app")

    if app_has_binary?(ns_app)
      rel = ns_target.gsub("#{root_dir}/", "")
      info "Emacs.app with binary already exists in \"#{rel}\", attempting to use."
      return ns_app
    elsif app_has_binary?(mac_app)
      rel = mac_target.gsub("#{root_dir}/", "")
      info "Emacs.app with binary already exists in \"#{rel}\", attempting to use."
      return mac_app
    end

    info "Compiling from source. This will take a while..."

    FileUtils.cd(source) do
      # Set up native-comp
      if options[:native_comp]
        info "Compiling with native-comp enabled"
        verify_native_comp
        gcc_info.verify_libgccjit
      end

      compile_env.each { |k, v| ENV[k] = v }

      local_lisp_path = [
        ENV.fetch("EMACS_LOCAL_LISP_PATH", "").split(":"),
        "/Library/Application Support/Emacs/${version}/site-lisp",
        "/Library/Application Support/Emacs/site-lisp",
        "/usr/local/share/emacs/site-lisp",
        "/opt/homebrew/share/emacs/site-lisp",
      ].flatten.join(":")

      if File.exist?("autogen.sh")
        info "Running autogen.sh to generate configure scripts..."
        run_cmd("./autogen.sh")
      end

      # Use relative path. This causes the app to be built locally in source/mac/Emacs.app.
      # This is necessary for correct internal linking (self-contained) and PDMP generation.
      configure_flags = [
        "--with-mac",
        "--with-modules",
        "--enable-locallisppath=#{local_lisp_path}",
        "--enable-mac-app=mac/Emacs.app",
        "--enable-mac-self-contained",
        "--with-mac-metal",
      ]

      configure_flags << "--with-xwidgets" if options[:xwidgets] && supports_xwidgets?
      configure_flags << "--with-tree-sitter" if options[:tree_sitter] && supports_tree_sitter?

      if options[:native_comp]
        if options[:native_full_aot]
          configure_flags << "--with-native-compilation=aot"
          info "Configuring with --with-native-compilation=aot for full AOT"
        else
          if native_comp_configure_flag
            configure_flags << native_comp_configure_flag
          else
            configure_flags << "--with-native-compilation=yes"
          end
        end
      end

      configure_flags << "--without-rsvg" if options[:rsvg] == false
      configure_flags << "--without-dbus" if options[:dbus] == false

      staging_prefix = File.join(output_dir, build_name, "staging")
      FileUtils.mkdir_p(staging_prefix)
      configure_flags << "--prefix=#{staging_prefix}"

      run_cmd("./configure", *configure_flags.compact, output_file: "configure_output.txt")

      if OS.sdk_version.major <= 10 && OS.sdk_version.minor <= 14
        info "Force disabling of aligned_alloc on macOS Mojave (10.14.x) and earlier"
        disable_alligned_alloc
      end

      make_flags = []
      make_flags += ["-j", options[:parallel].to_s] if options[:parallel]

      if options[:native_comp]
        make_flags << "BYTE_COMPILE_EXTRA_FLAGS=--eval '(setq comp-speed 2)'"
        if options[:native_full_aot]
          ENV.delete("NATIVE_FAST_BOOT")
        else
          ENV.delete("NATIVE_FULL_AOT")
          ENV["NATIVE_FAST_BOOT"] = "1"
        end
      end

      # Run make
      run_cmd("make", *make_flags.compact)

      gnubin = "/opt/homebrew/opt/coreutils/libexec/gnubin"
      if Dir.exist?(gnubin)
        ENV["PATH"] = "#{gnubin}:#{ENV["PATH"]}"
        info "Added coreutils gnubin to PATH: #{gnubin}"
      end

      # Note: We do NOT delete mac/Emacs.app here anymore.
      # Deleting it breaks the 'install' step because it expects artifacts generated by 'make'.

      # Run make install
      install_log = File.join(output_dir, build_name, "install_output.txt")
      sh_cmd = "make install 2>&1 | tee \"#{install_log}\""
      unless system("sh", "-lc", sh_cmd)
        warn "make install exited with non-zero status"
      end

      source_app_path = File.join(source, "mac", "Emacs.app")

      # === SANITIZATION PHASE ===
      if File.directory?(source_app_path)

        # 1. FIX ROOT NESTING (Emacs.app/Emacs.app)
        # This happens because 'make install' installs into 'mac/Emacs.app', which
        # effectively copies the new bundle INSIDE the existing one from the 'make' step.
        nested_root_app = File.join(source_app_path, "Emacs.app")

        if File.directory?(nested_root_app)
          warn "Detected nested Emacs.app at ROOT (Russian Doll). Unwrapping..."

          # The inner app is the "final" one. The outer one is the "build" artifact.
          # We need to replace the outer with the inner.
          temp_staging = File.join(source, "mac", "Emacs_temp_staging.app")

          # Move inner app to safe temp location
          FileUtils.mv(nested_root_app, temp_staging)

          # Defensive: Rescue Frameworks from Outer (Bad) just in case libs were linked there
          outer_frameworks = File.join(source_app_path, "Contents", "Frameworks")
          inner_frameworks = File.join(temp_staging, "Contents", "Frameworks")

          if File.directory?(outer_frameworks)
            FileUtils.mkdir_p(inner_frameworks)
            Dir.glob(File.join(outer_frameworks, "*")).each do |item|
              basename = File.basename(item)
              target_item = File.join(inner_frameworks, basename)
              unless File.exist?(target_item)
                info "Rescuing library from outer bundle: #{basename}"
                FileUtils.cp_r(item, inner_frameworks)
              end
            end
          end

          # Delete the corrupted outer shell
          FileUtils.rm_rf(source_app_path)

          # Move the clean inner app to be the main source app
          FileUtils.mv(temp_staging, source_app_path)
          info "Root nesting fixed. Inner app promoted."
        end

        # 2. FIX CONTENTS NESTING (Emacs.app/Contents/Emacs.app)
        # This is an older variant of the bug, kept for robustness.
        nested_content_app = File.join(source_app_path, "Contents", "Emacs.app")
        if File.directory?(nested_content_app)
          warn "Detected nested Emacs.app in CONTENTS. Rescuing..."

          nested_native = File.join(nested_content_app, "Contents", "Frameworks", "native-lisp")
          target_frameworks = File.join(source_app_path, "Contents", "Frameworks")

          if File.directory?(nested_native)
            info "Rescuing native-lisp..."
            FileUtils.mkdir_p(target_frameworks)
            target_native = File.join(target_frameworks, "native-lisp")
            if File.directory?(target_native)
              run_cmd("rsync", "-a", "#{nested_native}/", "#{target_native}/")
            else
              FileUtils.mv(nested_native, target_frameworks)
            end
          end
          FileUtils.rm_rf(nested_content_app)
        end
      end

      # --- FIX 3: Hoist PDMP file (Fixes Dump mode: nil) ---
      if File.directory?(source_app_path)
        macos_dir = File.join(source_app_path, "Contents", "MacOS")
        pdmp_files = Dir[File.join(macos_dir, "**", "*.pdmp")]

        pdmp_files.each do |pdmp_source|
          pdmp_name = File.basename(pdmp_source)
          pdmp_dest = File.join(macos_dir, pdmp_name)

          # Only move if it's not already in the right place
          if File.expand_path(pdmp_source) != File.expand_path(pdmp_dest)
            info "Hoisting PDMP file: #{pdmp_source} -> #{pdmp_dest}"
            FileUtils.cp(pdmp_source, pdmp_dest)
          end
        end

        # Verify
        final_pdmp = File.join(macos_dir, "Emacs.pdmp")
        if File.exist?(final_pdmp)
          info "PDMP successfully placed at #{final_pdmp}"
        else
          warn "WARNING: No Emacs.pdmp found in #{macos_dir} â€” dumped mode will fail"
        end
      end

      # --- FIX 4: Move App to Output ---
      final_app_dir = File.join(output_dir, build_name)
      final_app_path = File.join(final_app_dir, "Emacs.app")

      if File.directory?(source_app_path)
        info "Moving app to output directory..."
        FileUtils.mkdir_p(final_app_dir)
        FileUtils.rm_rf(final_app_path) if File.exist?(final_app_path)
        FileUtils.mv(source_app_path, final_app_dir)
      else
        fatal "Build failed: App not found at #{source_app_path}"
      end
    end

    alt_app = File.join(output_dir, build_name, "Emacs.app")
    return alt_app if app_has_binary?(alt_app)

    fatal "Build failed. Emacs.app not found."
  end

  def app_has_binary?(app_path)
    return false unless File.exist?(app_path)
    macos_dir = File.join(app_path, "Contents", "MacOS")

    binary = File.join(macos_dir, "Emacs")
    has_binary = File.file?(binary) && !File.symlink?(binary)

    # Extra validation for AOT build
    has_pdmp = File.exist?(File.join(macos_dir, "Emacs.pdmp"))

    has_binary && has_pdmp
  end

  def create_build_dir(app)
    target_dir = File.join(output_dir, build_name)
    app_abs = File.expand_path(app)

    # If app is already in the right place, just return
    if app_abs == File.join(target_dir, "Emacs.app")
      return [target_dir, app_abs]
    end

    info "Copying app to #{target_dir}"
    FileUtils.mkdir_p(target_dir)
    FileUtils.rm_rf(File.join(target_dir, "Emacs.app"))
    cmd("cp", "-a", app, target_dir)
    [target_dir, File.join(target_dir, File.basename(app))]
  end

  def sanitize_bundle_dirs(app)
    return unless File.directory?(app)
    Dir[File.join(app, "**", "*")].sort_by { |x| -x.length }.each do |path|
      next unless File.directory?(path)
      next if path == app
      base = File.basename(path)
      next unless base.include?(".")
      next if base.end_with?(".app")

      parent = File.dirname(path)
      new_path = File.join(parent, base.gsub(".", "_"))

      begin
        FileUtils.mv(path, new_path)
        if path.include?("/libexec/") && base.match?(/apple-darwin/)
          FileUtils.ln_s(File.basename(new_path), path)
        end
      rescue => e
        warn "Failed to sanitize #{path}: #{e.message}"
      end
    end
  end

  def self_sign_app(app)
    Dir[File.join(app, "**", "_CodeSignature")].each { |d| FileUtils.rm_rf(d) }
    sanitize_bundle_dirs(app)
    super(app)
  end
end

if __FILE__ == $PROGRAM_NAME
  begin
    cli_options = CLIOptions.parse(ARGV)
    Output.log_level = cli_options.delete(:log_level)
    work_dir = cli_options.delete(:work_dir)
    build = MacPortBuild.new(work_dir, ARGV.shift, cli_options)

    if cli_options[:info]
      build.print_info
    elsif cli_options[:preview]
      build.print_preview
    else
      build.build
    end
  rescue Error => e
    warn "ERROR: #{e.message}"
    exit 1
  end
end
