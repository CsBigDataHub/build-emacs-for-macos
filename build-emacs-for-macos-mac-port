#!/usr/bin/env ruby
# frozen_string_literal: true

# Load the main NS-port build script.
# This loads the Build class and all its dependencies.
load File.join(__dir__, "build-emacs-for-macos")

class MacPortBuild < Build
  def initialize(root_dir, ref = nil, options = {})
    # Set defaults specific to Mac port
    options = (options || {}).dup
    
    # Mac port xwidgets support may differ or require specific setup; 
    # default to false to avoid build issues unless explicitly requested.
    options[:xwidgets] = false unless options.key?(:xwidgets)

    # Ensure default dist_include files are present for debugging/verification
    if options[:dist_include].nil?
      options[:dist_include] = ["configure_output.txt", "COPYING"]
    else
      defaults = ["configure_output.txt", "COPYING"]
      options[:dist_include] = (options[:dist_include] + defaults).uniq
    end
    
    super(root_dir, ref, options)
  end

  private

  # Use jdtsmith/emacs-mac by default unless overridden via CLI
  def github_src_repo
    @github_src_repo ||= options[:github_src_repo] || "jdtsmith/emacs-mac"
  end

  # The upstream NS-port helper (macos-startup patch) should NOT be applied
  # to the Mac port. Override parent behavior to no-op.
  def apply_macos_startup_patch(_target)
    info "Skipping NS-port macOS startup patch for Mac-port"
  end

  # Build name should indicate this is a Mac port build
  def build_name
    return @build_name if @build_name
    return @build_name = options[:build_name] if options[:build_name]

    metadata = [
      "MacPort",
      meta[:date]&.strftime("%Y-%m-%d"),
      meta[:sha][0..6],
      meta[:ref],
      "macOS-#{OS.sdk_version}",
      OS.arch,
    ].compact.map { |v| v.gsub(/[^\w_-]+/, "-") }

    @build_name = "Emacs.#{metadata.join(".")}"
  end

  # Override compile_source to handle Mac port specific flags and build process
  def compile_source(source)
    # Check for pre-built app in 'mac/' (not 'nextstep/')
    mac_app = File.join(source, "mac", "Emacs.app")
    
    if app_has_binary?(mac_app)
      info "Emacs.app already exists in mac/, attempting to use."
      return mac_app
    end

    info "Compiling Mac port from source. This will take a while..."

    FileUtils.cd(source) do
      # Run autogen if necessary
      if File.exist?("autogen.sh")
        run_cmd "./autogen.sh"
      elsif File.exist?("autogen/copy_autogen")
        run_cmd "autogen/copy_autogen"
      end

      # Verify native-comp dependencies if requested
      if options[:native_comp]
        info "Compiling with native-comp enabled"
        verify_native_comp
        gcc_info.verify_libgccjit
      end

      # Apply environment variables (CFLAGS, LDFLAGS, etc.) from parent class
      compile_env.each { |k, v| ENV[k] = v }

      # Construct Mac port specific configure flags
      configure_flags = [
        "--with-mac",                  # Enable Mac port
        "--enable-mac-self-contained", # Build self-contained app structure
        "--with-mac-metal",            # Enable Metal backend
        "--with-modules",
      ]

      # Note: We do NOT use --enable-mac-app=yes here. 
      # That flag typically triggers 'make install' behavior to /Applications immediately.
      # We rely on 'make' creating the staging app in 'mac/' directory.

      # Add optional features
      configure_flags << "--with-xwidgets" if options[:xwidgets] && supports_xwidgets?
      configure_flags << "--with-tree-sitter" if options[:tree_sitter] && supports_tree_sitter?
      configure_flags << "--without-rsvg" if options[:rsvg] == false
      configure_flags << "--without-dbus" if options[:dbus] == false

      # Handle native-compilation flags
      if options[:native_comp]
        if options[:native_full_aot]
          configure_flags << "--with-native-compilation=aot"
        else
          # Use parent logic to determine the correct flag
          flag = native_comp_configure_flag
          configure_flags << flag if flag
        end
      end

      # Run configure
      run_cmd("./configure", *configure_flags.compact, output_file: "configure_output.txt")

      # Disable aligned_alloc on Mojave and below
      if OS.sdk_version.major <= 10 && OS.sdk_version.minor <= 14
        info "Force disabling of aligned_alloc on macOS Mojave (10.14.x) and earlier"
        disable_alligned_alloc
      end

      # Prepare make flags
      make_flags = []
      make_flags += ["-j", options[:parallel].to_s] if options[:parallel]

      if options[:native_comp]
        make_flags << "BYTE_COMPILE_EXTRA_FLAGS=--eval '(setq comp-speed 2)'"
        if options[:native_full_aot]
          info "Using native compile full AOT"
          make_flags << "NATIVE_FULL_AOT=1"
          ENV.delete("NATIVE_FAST_BOOT")
        else
          ENV.delete("NATIVE_FULL_AOT")
          ENV["NATIVE_FAST_BOOT"] = "1"
        end
      end

      # Build
      run_cmd "make", *make_flags.compact

      # Mac port creates the app in 'mac' subdirectory after make
      # (make install would move it to /Applications)
      final_app = File.join(source, "mac", "Emacs.app")
      
      fatal "Build failed. Emacs.app not found at #{final_app}" unless app_has_binary?(final_app)
      
      final_app
    end
  end

  # Prevent applying NS-port patches. Only user-specified patches are allowed.
  def build_patches
    p = []

    options[:patches].each do |patch_str|
      patch = {}
      if valid_url?(patch_str)
        patch[:url] = patch_str
      elsif File.exist?(patch_str)
        patch[:file] = patch_str
      else
        fatal "Patch file or URL not found: #{patch_str}"
      end
      p << patch
    end

    p.uniq
  end

  # Helper to check if an Emacs.app actually contains a compiled binary
  def app_has_binary?(app_path)
    return false unless File.exist?(app_path)

    # Check for the main Emacs binary in standard locations
    # Mac port might name the binary based on architecture/deployment target
    binary_paths = [
      File.join(app_path, "Contents", "MacOS", "Emacs"),
      File.join(app_path, "Contents", "MacOS", "Emacs-arm64-11"),
      File.join(app_path, "Contents", "MacOS", "Emacs-x86_64-10_14"),
    ]

    binary_paths.any? { |p| File.exist?(p) && File.file?(p) && !File.symlink?(p) }
  end

  # Override handle_native_lisp for Mac port specific structure
  def handle_native_lisp(app)
    return unless options[:native_comp]

    contents_dir = File.join(app, "Contents")
    FileUtils.cd(contents_dir) do
      # Mac port often places native-lisp in different locations
      source = Dir[
        "MacOS/lib/emacs/**/native-lisp",
        "MacOS/libexec/emacs/**/eln-cache",
        "Frameworks/native-lisp",
        "native-lisp" # Sometimes at root of Contents
      ].first

      # Skip if no native-lisp found
      return if source.nil?

      info "Processing native-lisp for Mac port..."

      # Create lisp symlink if needed
      if !File.exist?("lisp") && File.exist?("Resources/lisp")
        run_cmd("ln", "-s", "Resources/lisp", "lisp")
      end

      # Check for folder name containing two dots (.), which causes codesign failures
      eln_file = Dir[File.join(source, "**", "*.eln")].first
      return unless eln_file

      eln_dir = File.dirname(eln_file)

      if eln_dir.match?(%r{/.+\..+\..+/})
        base = File.basename(eln_dir)
        parent = File.dirname(eln_dir)

        until [".", "/", contents_dir].include?(parent)
          if base.match?(/\..+\./)
            old_name = File.join(parent, base)
            new_name = File.join(parent, base.gsub(/\.(.+)\./, '-\\1-'))
            
            info "Renaming: #{old_name} --> #{new_name}"
            cmd("mv", old_name, new_name)
          end

          base = File.basename(parent)
          parent = File.dirname(parent)
        end

        # Patch pdmp if we renamed directories
        eln_parts = eln_dir.match(%r{/(\d+\.\d+\.\d+)/native-lisp/(\d+\.\d+\.\d+-\w+)(?:/.+)?$}i)
        patch_dump_native_lisp_paths(app, eln_parts[1], eln_parts[2]) if eln_parts
      end

      # Create symlink to native-lisp if needed
      target = File.basename(source)
      run_cmd("ln", "-s", source, target) unless File.exist?(target)
    end
  end

  # Sanitize bundle subdirectory names that contain two or more dots which
  # cause Apple's codesign to reject the bundle.
  def sanitize_bundle_dirs(app)
    return unless File.exist?(app) && File.directory?(app)

    # Walk entire bundle and rename any DIRECTORY with two+ dots in basename
    # Process deepest paths first
    entries = Dir[File.join(app, "**", "*")]
    entries.sort_by! { |e| -e.length }

    entries.each do |path|
      next if path == app
      next unless File.directory?(path)

      base = File.basename(path)
      next unless base.match?(/\..+\./)

      parent = File.dirname(path)
      new_base = base.gsub(".", "_")
      old_name = path
      new_name = File.join(parent, new_base)

      # Skip the .app bundle itself
      next if old_name.end_with?(".app") && old_name == app

      # Check if this is a darwin architecture directory under libexec/
      # These paths are compiled into the Emacs binary, so we need a symlink
      is_libexec_arch_dir = path.include?("/libexec/") &&
                            base.match?(/^(aarch64|x86_64|arm64)-apple-darwin\d+\.\d+\.\d+$/)

      info "Sanitizing bundle directory: #{old_name} --> #{new_name}"

      begin
        # Ensure parent is writable
        File.chmod(0o775, parent) unless File.writable?(parent)

        # Handle name collision
        if File.exist?(new_name)
          timestamp = Time.now.strftime("%s")
          new_name = "#{new_name}_#{timestamp}"
        end

        FileUtils.mv(old_name, new_name)

        # Create symlink for libexec arch directories
        if is_libexec_arch_dir
          info "Creating symlink: #{base} -> #{File.basename(new_name)}"
          FileUtils.ln_s(File.basename(new_name), old_name)
        end
      rescue Errno::EACCES, Errno::EPERM => e
        warn "Permission error renaming #{old_name}, attempting sudo: #{e.message}"
        begin
          run_cmd("sudo", "mv", old_name, new_name)
          if is_libexec_arch_dir
            run_cmd("sudo", "ln", "-s", File.basename(new_name), old_name)
          end
        rescue Error => ee
          fatal "Failed to rename #{old_name} to #{new_name}: #{ee.message}"
        end
      rescue => e
        warn "Failed to rename #{old_name}: #{e.message}"
        next
      end

      # Patch Emacs.pdmp if this looks like a native-lisp path
      eln_parts = old_name.match(%r{/(\d+\.\d+\.\d+)/native-lisp/(\d+\.\d+\.\d+-\w+)(?:/.+)?$}ix)
      patch_dump_native_lisp_paths(app, eln_parts[1], eln_parts[2]) if eln_parts
    end
  end

  # Override create_build_dir to handle specific Mac port structure and copy native-lisp
  def create_build_dir(app)
    app_name = File.basename(app)
    target_dir = File.join(output_dir, build_name)
    target_app = File.join(target_dir, app_name)
    
    # If Mac port installed directly to output_dir (unlikely but possible), sanitize in place
    if File.expand_path(app).start_with?(File.expand_path(output_dir))
      info "Mac port installed to output directory, sanitizing in place"
      sanitize_bundle_dirs(app)
      return [target_dir, app]
    end
    
    # Use parent copy logic
    build_dir, app_path = super
    
    # According to emacs-mac docs, 'native-lisp' might be outside the bundle
    # if 'make install' was not run. We copy it in to ensure a self-contained app.
    # We rely on the parent's `cmd` method to fatal error if copy fails,
    # so we do not add expensive recursive file counting here for performance.
    native_lisp_src = File.join(source_dir, "native-lisp")
    if Dir.exist?(native_lisp_src)
      target_lisp_dir = File.join(app_path, "Contents", "native-lisp")
      unless File.exist?(target_lisp_dir)
        info "Copying native-lisp from source to app bundle..."
        FileUtils.mkdir_p(target_lisp_dir)
        # Use cp -a to preserve attributes/links. 
        cmd("cp", "-a", File.join(native_lisp_src, "."), target_lisp_dir)
      end
    end

    sanitize_bundle_dirs(app_path)
    [build_dir, app_path]
  end
end

if __FILE__ == $PROGRAM_NAME
  begin
    cli_options = CLIOptions.parse(ARGV)
    Output.log_level = cli_options.delete(:log_level)
    work_dir = cli_options.delete(:work_dir)

    build = MacPortBuild.new(work_dir, ARGV.shift, cli_options)

    if cli_options[:info]
      build.print_info
    elsif cli_options[:preview]
      build.print_preview
    elsif cli_options[:clean_macho_binary]
      macho_cleaner = MachOCleaner.new(cli_options[:clean_macho_binary])
      if macho_cleaner.duplicate_rpaths?
        build.info "Removing duplicate RPATHs from " \
                   "#{cli_options[:clean_macho_binary]}..."
        macho_cleaner.clean!
        build.info "Cleaned duplicate RPATHs successfully!"
      else
        build.info "No duplicate RPATHs found."
      end
    else
      build.build
    end
  rescue Error => e
    warn "ERROR: #{e.message}"
    exit 1
  end
end
