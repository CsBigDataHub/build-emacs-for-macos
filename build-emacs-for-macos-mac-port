#!/usr/bin/env ruby
# frozen_string_literal: true

# Lightweight wrapper reusing build-emacs-for-macos implementation
# to build "Mac port" (jdtsmith/emacs-mac) without applying
# NS-port specific patches. This file delegates nearly all behavior to
# the original build-emacs-for-macos script by subclassing Build and
# overriding a few methods.

# Load the main NS-port build script by exact filename (no .rb extension).
# Use `load` because `require_relative` appends ".rb" which does not match
# the executable script filename used in this repo.
load File.join(__dir__, "build-emacs-for-macos")

class MacPortBuild < Build
  def initialize(root_dir, ref = nil, options = {})
    # Set default dist_include files (configure_output.txt and COPYING) when
    # not provided by the caller. Merge with any existing dist_include option.
    options = (options || {}).dup
    if options[:dist_include].nil?
      options[:dist_include] = ["configure_output.txt", "COPYING"]
    else
      # ensure default files are present without duplication
      defaults = ["configure_output.txt", "COPYING"]
      options[:dist_include] = (options[:dist_include] + defaults).uniq
    end

    # Disable rsvg by default for mac-port builds
    options[:rsvg] = false if options[:rsvg].nil?

    super(root_dir, ref, options)
  end

  private

  # Use jdtsmith/emacs-mac by default unless overridden via --github-src-repo
  def github_src_repo
    @github_src_repo ||= options[:github_src_repo] || "jdtsmith/emacs-mac"
  end

  # Override build_name to include "mac-port" identifier in the build name
  def build_name
    return @build_name if @build_name
    return @build_name = options[:build_name] if options[:build_name]

    metadata =
      [
        meta[:date]&.strftime("%Y-%m-%d"),
        meta[:sha][0..6],
        meta[:ref],
        "mac-port",
        "macOS-#{OS.sdk_version}",
        OS.arch,
      ].compact.map { |v| v.gsub(/[^\w_-]+/, "-") }

    @build_name = "Emacs.#{metadata.join(".")}"
  end

  # The upstream NS-port helper (macos-startup patch) should NOT be applied
  # to the Mac port. The parent extract_tarball calls apply_macos_startup_patch;
  # override it to no-op.
  def apply_macos_startup_patch(_target)
    info "Skipping NS-port macOS startup patch for Mac-port"
  end

  # Prevent applying NS-port patches. Only user-specified patches are allowed
  # via the --patch CLI option.
  def build_patches
    p = []
    options[:patches].each do |patch_str|
      patch = {}
      if valid_url?(patch_str)
        patch[:url] = patch_str
      elsif File.exist?(patch_str)
        patch[:file] = patch_str
      else
        fatal "Patch file or URL not found: #{patch_str}"
      end
      p << patch
    end
    p.uniq
  end

  # Override compile_source to handle relative paths, nested bundles, and move app.
  def compile_source(source)
    # Accept either mac-port or NS-port style prebuilt app directories
    ns_target = File.join(source, "nextstep")
    mac_target = File.join(source, "mac")
    ns_app = File.join(ns_target, "Emacs.app")
    mac_app = File.join(mac_target, "Emacs.app")

    if app_has_binary?(ns_app)
      rel = ns_target.gsub("#{root_dir}/", "")
      info "Emacs.app with binary already exists in \"#{rel}\", attempting to use."
      return ns_app
    elsif app_has_binary?(mac_app)
      rel = mac_target.gsub("#{root_dir}/", "")
      info "Emacs.app with binary already exists in \"#{rel}\", attempting to use."
      return mac_app
    end

    info "Compiling from source. This will take a while..."

    FileUtils.cd(source) do
      # Set up native-comp if requested
      if options[:native_comp]
        info "Compiling with native-comp enabled"
        verify_native_comp
        gcc_info.verify_libgccjit
      end

      # Apply the compile environment
      compile_env.each { |k, v| ENV[k] = v }

      local_lisp_path = [
        ENV.fetch("EMACS_LOCAL_LISP_PATH", "").split(":"),
        "/Library/Application Support/Emacs/${version}/site-lisp",
        "/Library/Application Support/Emacs/site-lisp",
        "/usr/local/share/emacs/site-lisp",
        "/opt/homebrew/share/emacs/site-lisp",
      ].flatten.join(":")

      # --- CLEANUP: Remove existing mac/Emacs.app to ensure fresh build ---
      # If this directory exists from a previous failed or dirty build,
      # make might get confused or merge artifacts.
      if Dir.exist?(mac_target)
        info "Cleaning up existing mac build directory: #{mac_target}"
        FileUtils.rm_rf(mac_target)
      end

      # Build mac-port specific configure flags
      # Note: mac_app_path is calculated but NOT used in configure flags.
      # We use a relative path to ensure the build system calculates pdmp/eln paths correctly.
      mac_app_path = File.join(output_dir, build_name)

      configure_flags = [
        "--with-mac",
        "--with-modules",
        "--enable-locallisppath=#{local_lisp_path}",
        "--enable-mac-app=mac/Emacs.app", # Use relative path for correct internal linking
        "--enable-mac-self-contained",
        "--with-mac-metal",
      ]

      configure_flags << "--with-xwidgets" if options[:xwidgets] && supports_xwidgets?
      configure_flags << "--with-tree-sitter" if options[:tree_sitter] && supports_tree_sitter?

      # Native-comp configuration
      if options[:native_comp]
        if options[:native_full_aot]
          # This tells configure to generate Makefile with AOT rules
          configure_flags << "--with-native-compilation=aot"
          info "Configuring with --with-native-compilation=aot for full AOT"
        else
          # Standard native-comp without AOT
          if native_comp_configure_flag
            configure_flags << native_comp_configure_flag
          else
            configure_flags << "--with-native-compilation=yes"
          end
        end
      end

      # Keep existing behavior for rsvg/dbus flags
      configure_flags << "--without-rsvg" if options[:rsvg] == false
      configure_flags << "--without-dbus" if options[:dbus] == false

      # Ensure staging prefix so install does not write to /usr/local
      # This handles auxiliary files; App itself is built in source/mac
      staging_prefix = File.join(output_dir, build_name, "staging")
      FileUtils.mkdir_p(staging_prefix)
      configure_flags << "--prefix=#{staging_prefix}"

      # Run configure
      run_cmd("./configure", *configure_flags.compact, output_file: "configure_output.txt")

      # Disable aligned_alloc on Mojave and below
      if OS.sdk_version.major <= 10 && OS.sdk_version.minor <= 14
        info "Force disabling of aligned_alloc on macOS Mojave (10.14.x) and earlier"
        disable_alligned_alloc
      end

      make_flags = []
      make_flags += ["-j", options[:parallel].to_s] if options[:parallel]

      # Adjust native-comp make flags
      if options[:native_comp]
        make_flags << "BYTE_COMPILE_EXTRA_FLAGS=--eval '(setq comp-speed 2)'"

        if options[:native_full_aot]
          info "Building with AOT (configured via --with-native-compilation=aot)"
          # DO NOT set ENV["NATIVE_FULL_AOT"] = "1" - conflicts with configure
          # DO NOT add NATIVE_FULL_AOT=1 to make_flags - configure handles it
          ENV.delete("NATIVE_FAST_BOOT")
        else
          ENV.delete("NATIVE_FULL_AOT")
          ENV["NATIVE_FAST_BOOT"] = "1"
        end
      end

      # Run make
      run_cmd("make", *make_flags.compact)

      # Add coreutils gnubin to PATH if present
      gnubin = "/opt/homebrew/opt/coreutils/libexec/gnubin"
      if Dir.exist?(gnubin)
        ENV["PATH"] = "#{gnubin}:#{ENV["PATH"]}"
        info "Added coreutils gnubin to PATH: #{gnubin}"
      end

      # Run make install
      install_log = File.join(output_dir, build_name, "install_output.txt")
      sh_cmd = "make install 2>&1 | tee \"#{install_log}\""
      unless system("sh", "-lc", sh_cmd)
        warn "make install exited with non-zero status"
      end

      # --- CLEANUP: Remove source code copied to Resources/etc ---
      # make install sometimes copies the source directory into Resources/etc/src.
      # This bloats the app and can cause "unsealed contents" issues if nested bundles exist.
      src_in_resources = File.join(mac_target, "Emacs.app", "Contents", "Resources", "etc", "src")
      if Dir.exist?(src_in_resources)
        info "Removing source directory from bundle Resources/etc/src..."
        FileUtils.rm_rf(src_in_resources)
      end

      # --- CRITICAL FIX: Sanitize Nested Bundle ---
      # Native-comp AOT sometimes causes make install to create a nested Emacs.app
      # structure: Emacs.app/Contents/Emacs.app/Contents/Frameworks/native-lisp/
      # This causes codesign to fail with "unsealed contents present in the bundle root"

      source_app_path = File.join(source, "mac", "Emacs.app")

      if File.directory?(source_app_path)
        # Check for invalid nested bundle
        nested_app = File.join(source_app_path, "Contents", "Emacs.app")

        if File.directory?(nested_app)
          warn "Detected invalid nested Emacs.app bundle - fixing structure..."

          # 1. Rescue native-lisp directory
          nested_frameworks = File.join(nested_app, "Contents", "Frameworks")
          nested_native_lisp = File.join(nested_frameworks, "native-lisp")
          target_frameworks = File.join(source_app_path, "Contents", "Frameworks")

          if File.directory?(nested_native_lisp)
            info "Rescuing native-lisp from nested bundle..."
            FileUtils.mkdir_p(target_frameworks)
            target_native_lisp = File.join(target_frameworks, "native-lisp")

            # If target already has native-lisp, merge them (copy new files into it)
            # to avoid losing potentially existing cached eln files if rebuilding
            if File.directory?(target_native_lisp)
              info "Merging native-lisp directories..."
              # SYNTAX ERROR FIXED HERE:
              Dir.glob(File.join(nested_native_lisp, "*")).each do |file|
                dest_file = File.join(target_native_lisp, File.basename(file))
                FileUtils.cp_r(file, dest_file)
              end
            else
              # Move entire directory
              info "Moving native-lisp from nested to main bundle..."
              FileUtils.mv(nested_native_lisp, target_frameworks)
            end
          end

          # 2. Rescue orphaned resources
          nested_resources = File.join(nested_app, "Contents", "Resources")
          if File.directory?(nested_resources)
            target_resources = File.join(source_app_path, "Contents", "Resources")
            info "Checking for additional resources in nested bundle..."

            Dir.glob(File.join(nested_resources, '*')).each do |item|
              basename = File.basename(item)
              target_item = File.join(target_resources, basename)

              # Only copy if it doesn't exist in main bundle to avoid overwriting valid files
              unless File.exist?(target_item)
                warn "Found orphaned resource in nested bundle: #{basename}"
                info "Moving #{basename} to main bundle..."
                FileUtils.cp_r(item, target_item)
              end
            end
          end

          # 3. Delete the entire invalid nested bundle
          info "Removing nested bundle artifact..."
          FileUtils.rm_rf(nested_app)

          info "Bundle structure sanitized successfully"
        else
          info "No nested bundle detected - structure is correct"
        end
      else
        fatal "Build failed: Expected app not found at #{source_app_path}"
      end

      # --- Move App to Output Directory ---
      final_app_dir = File.join(output_dir, build_name)
      final_app_path = File.join(final_app_dir, "Emacs.app")

      info "Moving self-contained app from source to output directory..."
      FileUtils.mkdir_p(final_app_dir)

      # CRITICAL: Remove any existing app at destination to prevent
      # FileUtils.mv from creating ANOTHER nested structure
      if File.exist?(final_app_path)
        info "Removing existing app at destination to prevent nesting..."
        FileUtils.rm_rf(final_app_path)
      end

      info "Executing move: #{source_app_path} -> #{final_app_dir}"
      FileUtils.mv(source_app_path, final_app_dir)

      info "App successfully moved to #{final_app_path}"
    end

    # Return the produced app from the FINAL destination
    alt_app = File.join(output_dir, build_name, "Emacs.app")
    if app_has_binary?(alt_app)
      info "Detected Emacs.app with binary at output directory: #{alt_app}"
      return alt_app
    end

    # Fallback checks (should not be reached if Move succeeded)
    ns_app = File.join(source, "nextstep", "Emacs.app")
    mac_app = File.join(source, "mac", "Emacs.app")

    if app_has_binary?(ns_app)
      warn "Found app in 'nextstep' - move may have failed"
      return ns_app
    elsif app_has_binary?(mac_app)
      warn "Found app still in 'mac' source dir - move may have failed"
      return mac_app
    else
      fatal "Build failed. Emacs.app with binary not found after build."
    end
  end

  # Helper to check if an Emacs.app actually contains the compiled binary
  # (not just a skeleton directory from source extraction)
  def app_has_binary?(app_path)
    return false unless File.exist?(app_path)

    macos_dir = File.join(app_path, "Contents", "MacOS")
    return false unless File.directory?(macos_dir)

    # Look for the main Emacs binary (not shell scripts or symlinks)
    # The binary is typically named "Emacs" without extension
    binary = File.join(macos_dir, "Emacs")
    return true if File.file?(binary) && !File.symlink?(binary)

    # Also check for architecture-specific variants
    Dir[File.join(macos_dir, "Emacs-*")].any? do |p|
      File.file?(p) && !File.symlink?(p)
    end
  end

  # Override create_build_dir to handle cases where `make install` has already
  # created the output build directory (common for mac-port --enable-mac-app
  # install targets). If the target dir exists and already contains the
  # produced Emacs.app, treat it as a successful build instead of failing.
  def create_build_dir(app)
    app_name = File.basename(app)
    target_dir = File.join(output_dir, build_name)
    target_dir_abs = File.expand_path(target_dir)
    app_abs = File.expand_path(app)

    if File.exist?(target_dir)
      info "Output directory #{target_dir} already exists."

      # If the produced app already lives inside the expected target directory,
      # use it rather than attempting to copy into an existing directory.
      if app_abs.start_with?(target_dir_abs + "/") || app_abs == File.join(target_dir_abs, app_name)
        info "Using existing Emacs.app in #{target_dir} as build output"
        return [target_dir, app_abs]
      else
        fatal "Output directory #{target_dir} already exists, please delete it and try again"
      end
    end

    info "Copying \"#{app_name}\" to: #{target_dir}"

    FileUtils.mkdir_p(target_dir)
    cmd("cp", "-a", app, target_dir)

    options[:dist_include]&.each do |filename|
      src = File.join(source_dir, filename)
      if File.exist?(src)
        info "Copying \"#{filename}\" to: #{target_dir}"
        cmd("cp", "-pRL", src, target_dir)
      else
        info "Warning: #{filename} does not exist in #{source_dir}"
      end
    end

    [target_dir, File.join(target_dir, File.basename(app))]
  end

  # Sanitize bundle subdirectory names that contain two or more dots which
  # cause Apple's codesign to reject the bundle. Replace dots with underscores
  # in offending directory names and apply native-lisp pdmp patching when we
  # detect native-lisp layout patterns.
  #
  # IMPORTANT: We only sanitize DIRECTORIES, not files. Library files (.dylib,
  # .so, .eln) have their install names managed by LibEmbedder and must keep
  # their original names to match the @rpath references in binaries.
  #
  # For directories under libexec/ that match the darwin arch pattern
  # (e.g., aarch64-apple-darwin25.1.0), we rename them AND create a symlink
  # from the original name to the new name, because Emacs has these paths
  # compiled into the binary.
  def sanitize_bundle_dirs(app)
    return unless File.exist?(app) && File.directory?(app)

    # Walk entire bundle (excluding the top-level .app itself) and rename any
    # DIRECTORY whose basename contains two or more dots. We process the
    # longest paths first so child entries are moved before parents.
    entries = Dir[File.join(app, "**", "*")]
    entries.sort_by! { |e| -e.length }

    entries.each do |path|
      next if path == app
      # Only consider DIRECTORIES, not files. Files (especially .dylib) must
      # keep their original names to match install_name references.
      next unless File.directory?(path)

      base = File.basename(path)
      next unless base.match(/\..+\./)

      parent = File.dirname(path)
      new_base = base.gsub(".", "_")
      old_name = path
      new_name = File.join(parent, new_base)

      # Avoid touching the Emacs.app bundle directory itself
      next if old_name.end_with?(".app") && old_name == app

      # Check if this is a darwin architecture directory under libexec/
      # These paths are compiled into the Emacs binary, so we need to create
      # a symlink from the original name to the renamed directory.
      is_libexec_arch_dir = path.include?("/libexec/") &&
                            base.match(/^(aarch64|x86_64|arm64)-apple-darwin\d+\.\d+\.\d+$/)

      info "Sanitizing bundle directory: #{old_name} --> #{new_name}"

      begin
        # Ensure parent is writable so mv succeeds
        begin
          File.chmod(0o775, parent) unless File.writable?(parent)
        rescue => _e
          # ignore chmod failures, we'll try mv anyway
        end

        # Try a Ruby move first
        if File.exist?(new_name)
          # If new name already exists, create a unique name by appending timestamp
          timestamp = Time.now.strftime("%s")
          new_name = "#{new_name}_#{timestamp}"
        end

        FileUtils.mv(old_name, new_name)

        # For libexec arch directories, create a symlink from old name to new name
        # so Emacs can find its pdmp file and helper executables
        if is_libexec_arch_dir
          info "Creating symlink for libexec arch directory: #{base} -> #{File.basename(new_name)}"
          FileUtils.ln_s(File.basename(new_name), old_name)
        end
      rescue Errno::EACCES, Errno::EPERM => e
        warn "Permission error renaming #{old_name}, attempting sudo: #{e.message}"
        begin
          run_cmd("sudo", "mv", old_name, new_name)
          if is_libexec_arch_dir
            run_cmd("sudo", "ln", "-s", File.basename(new_name), old_name)
          end
        rescue Error => ee
          fatal "Failed to rename #{old_name} to #{new_name}: #{ee.message}"
        end
      rescue => e
        warn "Failed to rename #{old_name}: #{e.message}"
        next
      end

      # If this path looks like a native-lisp path (from older logic), patch
      # Emacs.pdmp to update any embedded native-lisp references.
      eln_parts = old_name.match(%r{/(
        \d+\.\d+\.\d+)/native-lisp/(\d+\.\d+\.\d+-\w+)(?:/.+)?$}ix)
      if eln_parts
        patch_dump_native_lisp_paths(app, eln_parts[1], eln_parts[2])
      end
    end
  end

  # Override signing to sanitize problematic directory names first.
  def self_sign_app(app)
    # Remove any pre-existing nested code signatures which can cause `codesign
    # --force --deep` to attempt to replace invalid signatures in subcomponents
    # before we sanitize paths. Deleting them ensures codesign performs a
    # clean sign pass after we rename offending directories.
    begin
      Dir[File.join(app, "**", "_CodeSignature")].each do |sigdir|
      next unless File.directory?(sigdir)
      info "Removing existing code signature: #{sigdir}"
      begin
        FileUtils.rm_rf(sigdir)
      rescue => e
        warn "Failed to remove #{sigdir}: #{e.message}"
      end
    end
    rescue => e
      warn "Failed enumerating existing signatures: #{e.message}"
    end

    sanitize_bundle_dirs(app)

    # Also remove any existing code signature files in nested bundles that may
    # confuse codesign (e.g. CodeResources). This is defensive â€” codesign will
    # recreate the necessary signature files.
    begin
      Dir[File.join(app, "**", "CodeResources")].each do |cr|
      next unless File.file?(cr)
      info "Removing existing CodeResources file: #{cr}"
      begin
        FileUtils.rm_f(cr)
      rescue => e
        warn "Failed to remove #{cr}: #{e.message}"
      end
    end
    rescue => e
      warn "Failed enumerating CodeResources files: #{e.message}"
    end

    super(app)
  end
end

if __FILE__ == $PROGRAM_NAME
  begin
    # Reuse the same CLIOptions parser from build-emacs-for-macos
    cli_options = CLIOptions.parse(ARGV)

    Output.log_level = cli_options.delete(:log_level)
    work_dir = cli_options.delete(:work_dir)

    build = MacPortBuild.new(work_dir, ARGV.shift, cli_options)

    if cli_options[:info]
      build.print_info
    elsif cli_options[:preview]
      build.print_preview
    elsif cli_options[:clean_macho_binary]
      macho_cleaner = MachOCleaner.new(cli_options[:clean_macho_binary])

      if macho_cleaner.duplicate_rpaths?
        build.info "Removing duplicate RPATHs from " \
                   "#{cli_options[:clean_macho_binary]}..."
        macho_cleaner.clean!
        build.info "Cleaned duplicate RPATHs successfully!"
      else
        build.info "No duplicate RPATHs found."
      end
    else
      build.build
    end
  rescue Error => e
    warn "ERROR: #{e.message}"
    exit 1
  end
end
