#!/usr/bin/env ruby
# frozen_string_literal: true

require 'English'
require 'date'
require 'erb'
require 'etc'
require 'fileutils'
require 'json'
require 'logger'
require 'net/http'
require 'open3'
require 'optparse'
require 'pathname'
require 'set'
require 'time'
require 'tmpdir'
require 'uri'
require 'yaml'
require 'macho'

class Error < StandardError
end

module Output
  class << self
    LEVELS = {
      debug: Logger::DEBUG,
      error: Logger::ERROR,
      fatal: Logger::FATAL,
      info: Logger::INFO,
      unknown: Logger::UNKNOWN,
      warn: Logger::WARN
    }.freeze

    def log_level
      LEVELS.key(logger.level)
    end

    def log_level=(level)
      logger.level = LEVELS.fetch(level&.to_sym)
    end

    def logger
      @logger ||=
        Logger
        .new($stderr)
        .tap do |logger|
          logger.level = Logger::INFO
          logger.formatter =
            proc do |severity, _datetime, _progname, msg|
              "==> #{severity.upcase}: #{msg}"
            end
        end
    end
  end

  %i[debug info warn error].each do |severity|
    define_method(severity) do |msg, newline: true|
      logger.send(severity, format_msg(msg, newline: newline))
    end
  end

  def fatal(msg = nil)
    raise Error, msg
  end

  private

  def logger
    Output.logger
  end

  def format_msg(msg, newline: true)
    msg = msg.join("\n") if msg.is_a?(Array)
    msg = msg.strip
    msg = "#{msg}\n" if newline
    msg
  end
end

module Helpers
  def valid_url?(uri)
    uri = URI.parse(uri)
    (uri.is_a?(URI::HTTP) || uri.is_a?(URI::HTTPS)) &&
      uri.host.respond_to?(:empty?) && !uri.host.empty?
  rescue URI::InvalidURIError
    false
  end
end

module System
  include Output

  def run_cmd(*args, output_file: nil)
    debug "executing: #{args.join(' ')}"
    cmd(*args, output_file: output_file)
  end

  def cmd(*args, output_file: nil)
    if output_file.nil?
      return system(*args) || fatal("Exit code: #{$CHILD_STATUS.exitstatus}")
    end

    # Handle output to both terminal and file
    File.open(output_file, 'w') do |file|
      Open3.popen3(*args) do |_stdin, stdout, stderr, wait_thread|
        stdout_thread = Thread.new do
          while (line = stdout.gets)
            puts line
            file.puts line
            file.flush
          end
        end

        stderr_thread = Thread.new do
          while (line = stderr.gets)
            $stderr.puts line # rubocop:disable Style/StderrPuts
            file.puts line
            file.flush
          end
        end

        [stdout_thread, stderr_thread, wait_thread].map(&:join)
        status = wait_thread.value
        return true if status.success?

        fatal("Exit code: #{status.exitstatus}")
      end
    end
  end
end

class OS
  def self.version
    @version ||= OSVersion.new
  end

  def self.sdk_version
    @sdk_version ||= SDKVersion.new
  end

  def self.arch
    @arch ||= `uname -m`.strip
  end
end

class AbstractVersion
  attr_reader :version

  def initialize
    str = load_version.strip
    @version = str.match(
      /(?<major>\d+)(?:\.(?<minor>\d+)(?:\.(?<patch>\d+))?)?/
    )
    warn "Parsed OS version string: '#{str}' => #{@version ? @version[0] : 'NIL'}"
  end

  def load_version
    raise NotImplementedError
  end

  def to_s
    @to_s ||= major >= 11 ? major.to_s : "#{major}.#{minor}"
  end

  def major
    @major ||= (@version && @version[:major]) ? @version[:major].to_i : 0
  end

  def minor
    @minor ||= (@version && @version[:minor]) ? @version[:minor].to_i : 0
  end

  def patch
    @patch ||= (@version && @version[:patch]) ? @version[:patch].to_i : 0
  end
end

class OSVersion < AbstractVersion
  def load_version
    `sw_vers -productVersion`.strip
  end
end

class SDKVersion < AbstractVersion
  def load_version
    ENV.fetch(
      'MACOSX_DEPLOYMENT_TARGET',
      `xcrun --show-sdk-version 2>/dev/null`.strip
    ).strip
  end
end

class Build
  include Output
  include System
  include Helpers

  DEFAULT_GITHUB_REPO = 'emacs-mirror/emacs'

  attr_reader :root_dir
  attr_reader :source_dir
  attr_reader :ref
  attr_reader :options
  attr_reader :gcc_info

  def initialize(root_dir, ref = nil, options = {})
    @root_dir = root_dir
    @ref = ref || 'master'
    @options = options
    @gcc_info = GccInfo.new(use_nix: options[:use_nix])
    load_plan(options[:plan]) if options[:plan]
  end

  def build
    unless meta[:sha] && meta[:date]
      fatal 'Failed to get commit info from GitHub.'
    end

    tarball = download_tarball(meta[:sha])
    @source_dir = extract_tarball(tarball, build_patches)
    autogen
    detect_native_comp if options[:native_comp].nil?
    app = compile_source(@source_dir)
    build_dir, app = create_build_dir(app)
    handle_native_lisp(app)

    if options[:icon_uri] || options[:tahoe_icon_uri] || options[:tahoe_icon_name]
      IconEmbedder.new(
        app,
        icon_uri: options[:icon_uri],
        tahoe_icon_uri: options[:tahoe_icon_uri],
        tahoe_icon_name: options[:tahoe_icon_name]
      ).embed
    end

    CLIHelperEmbedder.new(app).embed
    CSourcesEmbedder.new(app, @source_dir).embed
    LibEmbedder.new(
      app,
      [brew_dir, '/nix/store'],
      extra_libs,
      relink_eln_files: options[:relink_eln]
    ).embed
    GccLibEmbedder.new(app, gcc_info).embed if options[:native_comp]
    self_sign_app(app) if options[:self_sign]
    archive_build(build_dir) if options[:archive]
  end

  def print_info
    # Force-enable native-comp to ensure all env vars are setup.
    options[:native_comp] = true
    puts YAML.dump(
      {
        'os' => OS.version.to_s,
        'sdk' => OS.sdk_version.to_s,
        'arch' => OS.arch,
        'gcc' => {
          'root' => gcc_info.root_dir,
          'lib' => gcc_info.lib_dir,
          'darwin_lib' => gcc_info.darwin_lib_dir,
          'target_lib' => gcc_info.target_lib_dir,
          'target_darwin_lib' => gcc_info.target_darwin_lib_dir,
          'sanitized_target_darwin_lib_dir' =>
            gcc_info.sanitized_target_darwin_lib_dir,
          'version' => gcc_info.major_version
        },
        'libgccjit' => {
          'root' => gcc_info.libgccjit_root_dir,
          'lib' => gcc_info.libgccjit_lib_dir,
          'version' => gcc_info.libgccjit_major_version
        },
        'env' => {
          'CC' => compile_env['CC'],
          'CFLAGS' => compile_env['CFLAGS']&.split,
          'LDFLAGS' => compile_env['LDFLAGS']&.split,
          'LIBRARY_PATH' => compile_env['LIBRARY_PATH']&.split(':'),
          'PKG_CONFIG_PATH' => compile_env['PKG_CONFIG_PATH']&.split(':'),
          'PATH' => compile_env['PATH']&.split(':')
        }
      }
    )
  end

  def print_preview
    puts YAML.dump(
      {
        'build_name' => build_name,
        'emacs' => {
          'ref' => meta[:ref],
          'sha' => meta[:sha],
          'date' => meta[:date]
        },
        'os_version' => OS.version.to_s,
        'sdk_version' => OS.sdk_version.to_s,
        'arch' => OS.arch,
        'native_comp' => options[:native_comp],
        'gcc_version' => gcc_info.major_version,
        'libgccjit_version' => gcc_info.libgccjit_major_version
      }
    )
  end

  private

  def load_plan(filename)
    debug "Loading plan from: #{filename}"
    plan = YAML.safe_load(File.read(filename), permitted_classes: [:Time])
    @ref = plan.dig('source', 'ref')
    @meta = {
      sha: plan.dig('source', 'commit', 'sha'),
      ref: @ref,
      date: plan.dig('source', 'commit', 'date')
    }

    @output_dir = plan.dig('output', 'directory') if plan.dig('output', 'directory')
    @archive_filename = plan.dig('output', 'archive') if plan.dig('output', 'archive')
    @build_name = plan.dig('build', 'name') if plan.dig('build', 'name')
  end

  def tarballs_dir
    @tarballs_dir ||= File.join(root_dir, 'tarballs')
  end

  def sources_dir
    @sources_dir ||= File.join(root_dir, 'sources')
  end

  def output_dir
    @output_dir ||= options[:output] || File.join(root_dir, 'builds')
  end

  def github_src_repo
    @github_src_repo ||= options[:github_src_repo] || DEFAULT_GITHUB_REPO
  end

  def use_nix?
    !!options[:use_nix]
  end

  def brew_dir
    @brew_dir ||= `brew --prefix`.chomp
  end

  def extra_libs
    return [] if use_nix?
    return @extra_libs if @extra_libs

    libs = [
      File.join(brew_dir, 'opt/expat/lib/libexpat.1.dylib'),
      File.join(brew_dir, 'opt/libiconv/lib/libiconv.2.dylib'),
      File.join(brew_dir, 'opt/zlib/lib/libz.1.dylib')
    ]

    if options[:native_comp]
      libgcc_s =
        File.join(
          brew_dir,
          'lib',
          'gcc',
          gcc_info.major_version,
          'libgcc_s.1.dylib'
        )
      libs << libgcc_s if File.exist?(libgcc_s)
    end

    @extra_libs = libs
  end

  def command_exists?(command)
    system("which #{command} > /dev/null 2>&1")
  end

  def download_tarball(sha)
    FileUtils.mkdir_p(tarballs_dir)
    url = "https://github.com/#{github_src_repo}/tarball/#{sha}"
    filename = "#{github_src_repo.gsub(/[^a-zA-Z0-9-]+/, '-')}-#{sha[0..6]}.tgz"
    target = File.join(tarballs_dir, filename)

    if File.exist?(target)
      info "#{filename} already exists locally, attempting to use."
      return target
    end

    info 'Downloading tarball from GitHub. This could take a while, ' \
         'please be patient.'

    # Try gh cli first if use_gh_cli is enabled and gh is available
    if options[:use_gh_cli] && command_exists?('gh')
      download_tarball_with_gh_cli(sha, target)
    else
      download_tarball_with_curl(sha, url, target)
    end

    target
  end

  def download_tarball_with_gh_cli(sha, target)
    info 'Using gh cli to download tarball...'
    # gh api supports downloading release archives. Some gh versions do not
    # support --output, so capture binary output and write it to the target
    # file. If gh fails, fall back to curl.
    args = [
      'gh', 'api',
      '-H', 'Accept: application/vnd.github+json',
      "/repos/#{github_src_repo}/tarball/#{sha}"
    ]
    debug "executing: #{args.join(' ')}"

    begin
      output, status = Open3.capture2bin(*args)
    rescue StandardError => e
      warn "gh cli failed: #{e.message}, falling back to curl"
      return download_tarball_with_curl(
        sha,
        "https://github.com/#{github_src_repo}/tarball/#{sha}",
        target
      )
    end

    if status.success?
      File.open(target, 'wb') { |f| f.write(output) }
      return
    end

    warn "gh cli request failed with status: #{status.exitstatus}, falling back to curl"
    download_tarball_with_curl(sha, "https://github.com/#{github_src_repo}/tarball/#{sha}", target)
  end

  def download_tarball_with_curl(sha, url, target)
    args = ['curl', '-L', url, '-o', target]
    log_args = args.clone

    if options[:github_auth] && ENV['GITHUB_TOKEN']
      args =
        [args[0]] + ['-H', "Authorization: Token #{ENV['GITHUB_TOKEN']}"] +
        args[1..-1]
      log_args =
        [log_args[0]] + ['-H', '"Authorization: Token $GITHUB_TOKEN"'] +
        log_args[1..-1]
    end

    debug "executing: #{log_args.join(' ')}"
    cmd(*args)
  end

  def extract_tarball(filename, patches = [])
    FileUtils.mkdir_p(sources_dir)
    dirname = File.basename(filename).gsub(/\.\w+$/, '')
    target = File.join(sources_dir, dirname)

    if File.exist?(target)
      info "#{dirname} source tree exists, attempting to use."
      return target
    end

    info 'Extracting tarball...'
    result = run_cmd('tar', '-xzf', filename, '-C', sources_dir)
    fatal 'Tarball extraction failed.' unless result

    patches.each { |patch| apply_patch(patch, target) }
    apply_macos_startup_patch(target)

    # Patch configure.ac to prefer SDKROOT for WebKit headers
    cfg = File.join(target, 'configure.ac')
    if File.exist?(cfg)
      content = File.read(cfg)
      # Replace exactly one existing WEBKIT_CFLAGS line with a three-line
      # block that uses the SDK path. Only the first matching line will be
      # replaced to avoid touching other lines.
      lines = content.lines
      idx = lines.index { |l| l.match(/^\s*WEBKIT_CFLAGS=.*WebKit.framework\/Headers.*$/) }
      if idx
        lines[idx] = "SDKROOT=$(xcrun --show-sdk-path)\n" \
                     "WEBKIT_CFLAGS=\"-I${SDKROOT}/System/Library/Frameworks/WebKit.framework/Headers\"\n" \
                     "# WEBKIT_CFLAGS=\"-I/System/Library/Frameworks/WebKit.framework/Headers\"\n"
        File.write(cfg, lines.join)
        info 'Patched configure.ac to use SDKROOT for WEBKIT_CFLAGS'
      end
    end

    # Keep a copy of src after patches have been applied. This will be used to
    # embed C sources into the output Emacs.app bundle.
    cmd('cp', '-a', File.join(target, 'src'), File.join(target, 'src.orig'))

    target
  end

  def configure_help
    return @configure_help if @configure_help

    FileUtils.cd(source_dir) { @configure_help = `./configure --help` }
    @configure_help
  end

  def supports_xwidgets?
    @supports_xwidgets ||= !!configure_help.match(/\s+--with-xwidgets\s+/)
  end

  def supports_tree_sitter?
    @supports_tree_sitter ||=
      !!configure_help.match(/\s+--with-tree-sitter(\s|=).+/)
  end

  def supports_native_comp?
    @supports_native_comp ||= !native_comp_configure_flag.nil?
  end

  def native_comp_configure_match
    @native_comp_configure_match ||=
      configure_help.match(/\s+?(--with-native(?:comp|-compilation))(.+)?\s+?/)
  end

  def native_comp_configure_flag
    return @native_comp_configure_flag if @native_comp_configure_flag
    return unless native_comp_configure_match&.[](1)

    @native_comp_configure_flag = [
      native_comp_configure_match[1],
      native_comp_configure_flag_arg
    ].compact.join('=')
  end

  def native_comp_configure_flag_arg
    return @native_comp_configure_flag_arg if @native_comp_configure_flag_arg
    return if native_comp_configure_match&.[](2) != '[=TYPE]'

    @native_comp_configure_flag_arg =
      (options[:native_full_aot] ? 'aot' : 'yes')
  end

  def detect_native_comp
    info 'Detecting native-comp support...'
    options[:native_comp] = supports_native_comp?
    info 'Native-comp is: ' \
         "#{options[:native_comp] ? 'Supported' : 'Not supported'}"
  end

  def verify_native_comp
    return if supports_native_comp?

    fatal 'This emacs source tree does not support native-comp'
  end

  def autogen
    FileUtils.cd(source_dir) do
      if File.exist?('configure')
        info 'configure script exists, skipping autogen.'
        return
      end

      if File.exist?('autogen/copy_autogen')
        run_cmd 'autogen/copy_autogen'
      elsif File.exist?('autogen.sh')
        run_cmd './autogen.sh'
      end
    end
  end

  # rubocop:disable Naming/MethodName,Naming/VariableName
  def env_CFLAGS
    return @env_CFLAGS if @env_CFLAGS

    env = ENV.fetch('CFLAGS', nil)&.split || []
    env << '-O2'

    if options[:native_comp]
      env += [
        "-I#{File.join(gcc_info.root_dir, 'include')}",
        "-I#{File.join(gcc_info.libgccjit_root_dir, 'include')}"
      ]
    end

    env << '-march=native' if options[:native_march]
    env << '-mtune=native' if options[:native_mtune]
    env << '-fomit-frame-pointer' if options[:fomit_frame_pointer]

    if options[:fd_setsize].respond_to?(:>=) && options[:fd_setsize] >= 1024
      env += [
        "-DFD_SETSIZE=#{options[:fd_setsize]}",
        '-DDARWIN_UNLIMITED_SELECT'
      ]
    end

    if use_nix? && ENV['NIX_CFLAGS_COMPILE']
      env += ENV['NIX_CFLAGS_COMPILE'].split
    end

    # Group "-isystem <path>" flags together as a single flag. This allows us to
    # de-duplicate CFLAGS from NIX_CFLAGS_COMPILE.
    new_env = []
    isystem_flag = false
    env.each do |flag|
      if flag.strip == '-isystem'
        isystem_flag = true
      elsif isystem_flag
        new_env << "-isystem #{flag}"
        isystem_flag = false
      else
        new_env << flag
      end
    end

    @env_CFLAGS = new_env.compact.reject(&:empty?).uniq
  end

  def env_LDFLAGS
    return @env_LDFLAGS if @env_LDFLAGS

    env = ENV.fetch('LDFLAGS', nil)&.split || []
    # Ensure library re-linking and code signing will work after building.
    env << '-Wl,-headerpad_max_install_names'

    if options[:native_comp]
      env += [
        "-L#{gcc_info.lib_dir}",
        "-L#{gcc_info.darwin_lib_dir}",
        "-L#{gcc_info.libgccjit_lib_dir}",
        "-I#{File.join(gcc_info.root_dir, 'include')}",
        "-I#{File.join(gcc_info.libgccjit_root_dir, 'include')}"
      ]
    end

    env += ENV['NIX_LDFLAGS'].split if use_nix? && ENV['NIX_LDFLAGS']

    @env_LDFLAGS = env.compact.reject(&:empty?).uniq
  end

  def env_LIBRARY_PATH
    return @env_LIBRARY_PATH if @env_LIBRARY_PATH

    env = ENV.fetch('LIBRARY_PATH', nil)&.split || []

    if options[:native_comp]
      env += [
        gcc_info.lib_dir,
        gcc_info.darwin_lib_dir,
        gcc_info.libgccjit_lib_dir
      ]
    end

    env << '/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib'

    @env_LIBRARY_PATH = env.compact.reject(&:empty?).uniq
  end

  def env_PKG_CONFIG_PATH
    env = ENV.fetch('PKG_CONFIG_PATH', nil)&.split || []
    return env if use_nix?

    @env_PKG_CONFIG_PATH = (
      [
        File.join(brew_dir, 'lib/pkgconfig'),
        File.join(brew_dir, 'share/pkgconfig'),
        File.join(brew_dir, 'opt/expat/lib/pkgconfig'),
        File.join(brew_dir, 'opt/libxml2/lib/pkgconfig'),
        File.join(brew_dir, 'opt/ncurses/lib/pkgconfig'),
        File.join(brew_dir, 'opt/zlib/lib/pkgconfig'),
        File.join(
          brew_dir,
          'Homebrew/Library/Homebrew/os/mac/pkgconfig',
          OS.version.to_s
        )
      ] + env
    ).compact.reject(&:empty?).uniq
  end

  def env_PATH
    env = ENV.fetch('PATH', nil)&.split || []
    return env if use_nix?

    @env_PATH = (
      [
        File.join(brew_dir, 'opt/make/libexec/gnubin'),
        File.join(brew_dir, 'opt/coreutils/libexec/gnubin'),
        File.join(brew_dir, 'opt/gnu-sed/libexec/gnubin'),
        File.join(brew_dir, 'bin'),
        File.join(brew_dir, 'opt/texinfo/bin')
      ] + env
    ).compact.reject(&:empty?).uniq
  end
  # rubocop:enable Naming/MethodName,Naming/VariableName

  def compile_env
    return @compile_env if @compile_env

    env = {
      'CC' => use_nix? ? 'clang' : '/usr/bin/clang',
      'PATH' => env_PATH.join(':'),
      'PKG_CONFIG_PATH' => env_PKG_CONFIG_PATH.join(':')
    }

    if options[:native_comp]
      env['CFLAGS'] = env_CFLAGS.join(' ')
      env['LDFLAGS'] = env_LDFLAGS.join(' ')
      env['LIBRARY_PATH'] = env_LIBRARY_PATH.join(':')
    end

    @compile_env = env
  end

  def compile_source(source)
    target = File.join(source, 'nextstep')
    emacs_app = File.join(target, 'Emacs.app')

    if File.exist?(emacs_app)
      info 'Emacs.app already exists in ' \
           "\"#{target.gsub("#{root_dir}/", '')}\", attempting to use."
      return emacs_app
    end

    info 'Compiling from source. This will take a while...'

    FileUtils.cd(source) do
      if options[:native_comp]
        info 'Compiling with native-comp enabled'
        verify_native_comp
        gcc_info.verify_libgccjit
      end

      compile_env.each { |k, v| ENV[k] = v }

      local_lisp_path = [
        ENV.fetch('EMACS_LOCAL_LISP_PATH', '').split(':'),
        '/Library/Application Support/Emacs/${version}/site-lisp',
        '/Library/Application Support/Emacs/site-lisp',
        '/usr/local/share/emacs/site-lisp',
        '/opt/homebrew/share/emacs/site-lisp'
      ].flatten.join(':')

      configure_flags = [
        '--with-ns',
        '--with-modules',
        "--enable-locallisppath=#{local_lisp_path}"
      ]

      configure_flags << '--with-xwidgets' if options[:xwidgets] && supports_xwidgets?
      configure_flags << '--with-tree-sitter' if options[:tree_sitter] && supports_tree_sitter?
      configure_flags << native_comp_configure_flag if options[:native_comp]
      configure_flags << '--without-rsvg' if options[:rsvg] == false
      configure_flags << '--without-dbus' if options[:dbus] == false

      run_cmd(
        './configure', *configure_flags.compact,
        output_file: 'configure_output.txt'
      )

      # Disable aligned_alloc on Mojave and below. See issue:
      # https://github.com/daviderestivo/homebrew-emacs-head/issues/15
      if OS.sdk_version.major <= 10 && OS.sdk_version.minor <= 14
        info 'Force disabling of aligned_alloc on macOS Mojave (10.14.x) ' \
             'and earlier'
        disable_alligned_alloc
      end

      make_flags = []
      make_flags += ['-j', options[:parallel].to_s] if options[:parallel]

      if options[:native_comp]
        make_flags << "BYTE_COMPILE_EXTRA_FLAGS=--eval '(setq comp-speed 2)'"

        if options[:native_full_aot]
          info 'Using native compile full AOT'
          # We do not need to supply the full AOT make arg if
          # --with-native-compilation=aot configure flag is supported.
          make_flags << 'NATIVE_FULL_AOT=1' unless native_comp_configure_flag_arg
          ENV.delete('NATIVE_FAST_BOOT')
        else
          ENV.delete('NATIVE_FULL_AOT')
          ENV['NATIVE_FAST_BOOT'] = '1'
        end
      end

      run_cmd 'make', *make_flags.compact
      run_cmd 'make', 'install'
    end

    fatal 'Build failed.' unless File.exist?(emacs_app)
    emacs_app
  end

  def create_build_dir(app)
    app_name = File.basename(app)
    target_dir = File.join(output_dir, build_name)

    if File.exist?(target_dir)
      fatal "Output directory #{target_dir} already exists, " \
            'please delete it and try again'
    end

    info "Copying \"#{app_name}\" to: #{target_dir}"
    FileUtils.mkdir_p(target_dir)
    cmd('cp', '-a', app, target_dir)

    options[:dist_include]&.each do |filename|
      src = File.join(source_dir, filename)
      if File.exist?(src)
        info "Copying \"#{filename}\" to: #{target_dir}"
        cmd('cp', '-pRL', src, target_dir)
      else
        info "Warning: #{filename} does not exist in #{source_dir}"
      end
    end

    [target_dir, File.join(target_dir, File.basename(app))]
  end

  def handle_native_lisp(app)
    return unless options[:native_comp]

    contents_dir = File.join(app, 'Contents')
    FileUtils.cd(contents_dir) do
      source =
        Dir[
          'MacOS/libexec/emacs/**/eln-cache',
          'MacOS/lib/emacs/**/native-lisp'
        ].first

      # Skip creation of symlinks if *.eln files are not located in a location
      # known to be used by builds which need symlinks and other tweaks.
      return if source.nil?

      info 'Creating symlinks within Emacs.app needed for native-comp'

      if
